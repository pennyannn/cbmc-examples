import "Mul32.cry";

// load testall LLVM bytecode
m <- llvm_load_module "../testall.bc";

let mul32_spec = do {
  a <- crucible_fresh_var "a" (llvm_int 32);
  b <- crucible_fresh_var "b" (llvm_int 32);

  // bound : sqrt((2^32 - 1)/315)
  crucible_precond {{ a <= 3692 }};
  crucible_precond {{ b <= 3692 }};

  crucible_execute_func [ (crucible_term a), (crucible_term b) ];

  crucible_return (crucible_term {{ mul32 a b }});
};


print "Verifying mul32 using cvc5 ...";
llvm_verify
  m "mul32" [] true
  (mul32_spec)
  (do { w4_unint_cvc5 [];
  });

print "Verifying mul32 using z3 ...";
llvm_verify
  m "mul32" [] true
  (mul32_spec)
  (do { w4_unint_z3 [];
  });

let mul_ref_spec = do {
  a <- crucible_fresh_var "a" (llvm_int 32);
  b <- crucible_fresh_var "b" (llvm_int 32);

  crucible_execute_func [ (crucible_term a), (crucible_term b) ];

  crucible_return (crucible_term {{ mul32 a b }});
};

print "Verifying equivalence between mul_ref and the cryptol spec";
llvm_verify
  m "mul_ref" [] false
  (mul_ref_spec)
  (do { w4_unint_z3 [];
  });


// Direct equivalence between mul_ref and mul_32
print "Extracting reference term: mul_ref";
mul_ref <- llvm_extract m "mul_ref";
print "Extracting implementation term: mul32";
mul32 <- llvm_extract m "mul32";

print "Proving equivalence: mul_ref == mul32";
let thm = {{ \a b -> (a <= 3692) && (b <= 3692) ==> mul_ref a b == mul32 a b }};
result <- prove cvc5 thm;
print result;
